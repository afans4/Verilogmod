

# IC笔记

## 基本数电知识

### 常用逻辑门符号

![img](笔记.assets/024f78f0f736afc3302aaf81b919ebc4b745122b)

### CMOS逻辑电路

![image-20210720193804707](笔记.assets/image-20210720193804707.png)

+ N型MOS管：栅极输入高电平时导通；
+ P型MOS管：栅极输入低电平时导通；

**非门**

![image-20210720194247380](笔记.assets/image-20210720194247380.png)

**与非门**

![image-20210720194313947](笔记.assets/image-20210720194313947.png)

**或非门**

![image-20210720194328792](笔记.assets/image-20210720194328792.png)

**三态门/传输门**

![image-20210720194353560](笔记.assets/image-20210720194353560.png)

### 触发器与锁存器

+ 锁存器：电平敏感
+ 触发器：边沿敏感
+ 都属于时序电路；组合逻辑电路的输出只和当前输入有关，而时序电路的输出不仅与当前输入有关还和之前的输出有关

**SR锁存器**

基本SR锁存器由两个或非门组成

![在这里插入图片描述](笔记.assets/20200604132913386.jpg)

其功能表如下：

| S    | R    | 功能                   |
| ---- | ---- | ---------------------- |
| 0    | 0    | 保持                   |
| 0    | 1    | 置0                    |
| 1    | 0    | 置1                    |
| 1    | 1    | 非定义状态，最好不出现 |

SR锁存器需要约束：$SR=0$

**常见触发器表达式**

D触发器

$Q = D$

JK触发器

$Q^{n+1} = J{Q^{n}}'+K'Q^{n}$

T触发器

$Q^{n+1}=TQ^{n}{'}+T{'}Q^{n}$

SR触发器

$Q^{n+1}=S+R{'}Q^n$

***

### 环形振荡器

![image-20210721144117706](笔记.assets/image-20210721144117706.png)

**TPLH**为低电平到高电平所需时间，**TPHL**为高电平到低电平所需时间。

以图中振荡器为例分析：

+ 初始电平为高电平，经过5个非门取反后，变为低电平，再经过5个非门取反后变为高电平
+ 从高电平到低电平消耗时间为：$TPHL*3+TPLH*2$
+ 低电平到高电平消耗时间为：$TPLH*3+TPHL*2$
+ 单个周期时间为$N*(TPHL+TPLH)$，N为非门个数

***

### FPGA基本单元

LUT（查找表）

本质是一个RAM，事先确定存储值。

然后根据输入，输出对应地址结果

***

### 竞争与冒险

+ 组合逻辑电路
+ 由于信号电平翻转时会有一段时间处于亚稳态

![在这里插入图片描述](笔记.assets/20200509153439630.png)

+ 竞争：在组合电路中，信号经由不同的途径达到某一会合点的时间有先有后，这种现象称为竞争。

  冒险：由于竞争而引起电路输出发生瞬间错误现象称为冒险。表现为输出端出现了原设计中没有的窄脉冲，常称其为毛刺。

  竞争与冒险的关系：有竞争不一定会产生冒险，但有冒险就一定有竞争。

  在组合逻辑中，由于门的输入信号通路中经过了不同的延时，导致到达该门的时间不一致叫竞争。
  产生毛刺叫冒险。如果布尔式中有相反的信号则可能产生竞争和冒险现象。

判定依据：

- 如果输出端门电路的两个输入信号A和A’是输入变量A经过两个不同的传输途径而来，则当输入变量A的状态发生突变时输出端有可能产生尖峰脉冲，故**只要输出端的逻辑函数在一定条件下能简化成Y＝A＋ A’或 Y＝A · A’,则可判定存在竞争－冒险现象**

两种情况：

+ $Y=A+A'$，产生一个低电平
+ $Y = A\cdot A'$，产生一个尖峰脉冲，高电平脉冲

消除方法：

+ 接入滤波电容：在门电路的输出端并接一个很小的滤波电容，简单，但是会使输出波形变差

+ 引入选通脉冲：门电路的输入或者输出加一个选通控制器，使电路在输入稳定后再输出结果即可。

+ 修改逻辑设计：增加**冗余项**

  例子：

  $Y=AB+A'C$,当$B = C = 1$时：$Y = A + A ′$ 
  说明此电路存在竞争冒险现象。
  增加冗余项，$Y = A B + A ′ C + B C$ 

***

### 芯片功耗

$$
总功耗=开关功耗+短路功耗+静态功耗
$$

动态功耗包括开关功耗和短路功耗
$$
开关功耗=C\bullet V^2 \bullet F
$$
其中$C$为负载电容，$V$是电压，$F$是频率
$$
短路功耗 = V \bullet I(短路)
$$
其中$I(短路)$为在开关切换过程中N极和P极同时有效时发生的短路电流。
$$
静态功耗= V \cdot I(漏电)
$$
静态功耗（漏电功耗）是晶体管在电路稳定时出现的漏电造成的功耗

***

## 电路静态时序分析

> 参考材料
>
> https://zhuanlan.zhihu.com/p/87462839
>
> https://blog.csdn.net/verylogic/article/details/14261989?reload

##### 建立和保持时间检测

时序分析要求：

+ 在第二个FF的第二个上升沿到来前的建立时间前数据到达第二个FF的入口
+ 数据要保持到第二个上升沿后再加上保持时间后

经典分析模型如下：

![image-20210629212327146](笔记.assets/image-20210629212327146.png)

![image-20210629213711623](笔记.assets/image-20210629213711623.png)

以CLK的第一个上升沿为0时刻

FF1 CLK在T_clk1时出现第一个上升沿，此时，FF1打开，数据进入FF1

经过T_cko后，数据到达FF1的输出Q，

再经过T_logic后通过组合逻辑电路，再经过T_net线路延时到达FF2的输入。

总时间为$T_{cl1}+T_{clo}+T_{logic}+T_{net}$，

*时序要求数据在FF2 CLK的第二个上升沿到来前到达FF2输入，同时要满足建立时间和保持时间*

FF2 CLK的第二个上升沿的时刻为$T_{clk2}+T_{clkp}$,$T_{clkp}$为时钟周期

数据建立时间和保留时间要求为$T_{su}$和$T_{hold}$

因此建立时间要求如下
$$
T_{clk2}+T_{clkp}-T{su}>T_{clk1}+T_{clo}+T_{logic}+T_{net}
$$
可得到时钟周期的约束条件
$$
T_{clkp}>T_{clk1}-T_{clk2}+T_{clo}+T_{logic}+T_{net}+T{su}
$$
保持时间要求如下
$$
T_{clk2}+T_{clkp}+T_{hold}<T_{clk1}+T_{clo}+T_{logic}+T_{net}+T_{clkp}
$$
化简为
$$
T_{clk2}+T_{hold}<T_{clk1}+T_{clo}+T_{logic}+T_{net}
$$
例题如下

![](笔记.assets/image-20210629153338758.png)

##### 异步复位约束

+ 两种约束**recovery/removal check**

+ 针对**异步**reset和clk之间的关系

![image-20210719100502648](笔记.assets/image-20210719100502648.png)

**recovery**指：rst失效电平要在clk之前一定时间到来，保证在CLK采样时，DFF处于**非复位状态**，类似`~rst`的setup time。

![image-20210719100853124](笔记.assets/image-20210719100853124.png)

**removal**指：**复位有效信号**需要在clk到来之后还要保持多长时间，否则会出现复位不成功，类似`rst`的hold time

##### 部分名词

**False path**:在设计中，不需要满足setup/hold时序的数据路径需要设置成false path



##### 时序分析相关

> 系统最高工作频率是由最长路径决定的，也就是最长的组合逻辑路径决定

经典数字电路等效模型

![image-20210708094025787](笔记.assets/image-20210708094025787.png)

即组合逻辑+D触发器打拍，最长的组合逻辑延时决定了系统的最高工作频率。

**pipeline（流水线设计）**

> 用资源换时间

将一个长延时的组合逻辑拆开，在中间插入寄存器缓存中间数据，降低单次时钟周期中组合逻辑的延时，以此提高时钟频率。

+ comb1延时30ns，在其中插入一个寄存器，将comb1拆成两个延迟更低的组合逻辑，即可提高系统工作频率

流水线设计需要数据载入，也就是说流水线设计的第一个数据输出的延时会增加，但是在数据加载完成后，每个CLK都有一个数据输出。

**Retime（重定时）**

调整组合逻辑电路，使各个寄存器之间的组合逻辑延时相似，以提高系统工作频率。

+ 重定时将comb1和comb2调整为延时相当的两个组合逻辑，从而提高系统工作频率

![image-20210708095829259](笔记.assets/image-20210708095829259.png)

**Multcycle Path（多周期路径）**

##### 常见时序分析问题

+ 建立时间不满足时，即不满足$T_{setup}<T_{clk}+T_{skew}-T_{dq}-T_{comb}$，可以使用的解决方法有，
  + 从工艺手段降低$T_{setup}$
  + 降低时钟频率或增加时钟偏移时间
  + 减小逻辑延时或门传递时间
+ 保持时间不满足时，即不满足$T_{hold}<T_{dq}+T_{comb}$,解决方法有
  + 增加逻辑延时或门传递时间，常用方法是在传输路径上加入buffer延时。
  + 时钟频率与保持时间约束无关
+ 

***

## 跨时钟域处理（CDC）

> https://blog.csdn.net/vivid117/article/details/117567445
>
> 

##### 亚稳态

**产生原因**：不同时钟域导致的触发器的数据输入没有满足建立时间和保持时间，导致采集到一个无法确认的数据输入

+ 亚稳态是指信号跳变时，由于**不满足建立保持时间**，寄存器的输出端会输出中间电平，或者产生震荡等。亚稳态**不是一个持续的状态**，是一个短暂的状态。
+ 对于异步信号，一级寄存器永远会有亚稳态的可能。
+ 如果第一级寄存器出现亚稳态，亚稳态的时间如果在1个clock cycle之内恢复了，那么第二级寄存器会采样到稳定状态。如果亚稳态时间过于长超过1个clock cycle，那么第二级仍然有可能输出亚稳态。
+ 亚稳态不是纠错，如果产生亚稳态，那么采样值可能是不正确的，两级寄存器或者多级寄存器的级联是防止亚稳态状态在时序电路中传播扩散。

**亚稳态处理**

1. 降低系统时钟
2. 用反应更快的FF
3. 引入**同步机制**，防止亚稳态传播
4. 改善时钟质量，用边沿变化快速的时钟信号

**同步器**

常用2级同步器(打两拍)降低亚稳态发生的概率。

原理：亚稳态是一个短暂状态，二级同步器可以增加一个CLK的时间等待亚稳态稳定

+ 同步器能降低亚稳态发生的**概率**，但不能保证采集到**正确的信号**

即： 同步器或增加寄存器可以避免亚稳态的**传播**，但不能纠正**逻辑正确性**

##### 单比特跨时钟域处理

**常用处理方法**

慢时间到快时间域

1. 两级寄存器同步(打两拍)，(频率相差2倍以上)
2. 边沿检测同步器(频率相差2倍以上)，可避免快时钟多次采集到有效信号。
3. 握手处理(单比特少用)，一般用于时钟频率相差不大的情况(频率相差2倍以下)，为了避免快时钟**采样丢失**，进行握手的同步处理。

**边沿检测**

1. 上升沿检测

   快时钟先将输入信号进行两级同步处理，再进行一个时钟的延迟，**延迟后的信号取反**与**同步信号做与逻辑**，得到信号的上升沿。

2. 下降沿检测

   快时钟先将输入信号进行两级同步处理，再进行一个时钟的延迟，延迟后的信号与**取反后同步信号做与**逻辑，得到脉冲信号的下降沿。

3. 双边沿检测

   快时钟先将输入信号进行两级同步处理，再进行一个时钟的延迟，延迟后的信号与同步信号做**异或**逻辑，就可得到信号的双沿脉冲。

快时间到慢时间域同步

1. 电平拓展

   如果已知慢时钟域的时钟频率，可以考虑将快时钟域的信号进行电平扩展，使得足以被慢时钟域采样。

2. 脉冲同步器

   快时钟域中需要同步的是脉冲信号，将快时钟域脉冲同步为慢时钟域脉冲

   原理是**翻转电路+边沿检测电路**

   需要脉冲是**单脉冲信号**；多个脉冲之间需要**大于两个**慢时间同步周期

3. 握手处理

注意：

多个关联单比特信号不可以通过打拍的方式同步到目的时钟域，应该在原时钟域进行逻辑运算再锁存后打拍处理

##### 多比特数据跨时钟处理



***

## AMBA总线

### AHB与APB

![在这里插入图片描述](笔记.assets/20200722135414158.png)

#### AHB

>https://blog.csdn.net/ivy_reny/article/details/78144785

**特点：**

+ 单边沿操作
+ 没有三态设备
+ 突发传输
+ 事务分离
+ 多个主设备

**AHB模型**

![image-20210714163800508](笔记.assets/image-20210714163800508.png)

**总线接口**

| 名称         | 来源       | 描述                                                     |
| ------------ | ---------- | -------------------------------------------------------- |
| HCLK         | 时钟源     | 总线时钟，上升沿有效                                     |
| HRESETn      | 复位控制器 | 总线复位，低电平有效                                     |
| HADDR[31:0]  | 主机       | 32位地址                                                 |
| HTRANS[1:0]  | 主机       | 2位，传输类型；不连续、连续、空闲和忙                    |
| HWRITE       | 主机       | 传输方向，高电平为写传输，低电平为读传输                 |
| HSIZE[2:0]   | 主机       | 传输大小，以字节为单位，最高支持1024位                   |
| HBURST[2:0]  | 主机       | 突发传输类型，支持4、8、16位突发传输，增量或回环突发传输 |
| HPORT[3:0]   | 主机       | 保护控制信号                                             |
| HWDATA[31:0] | 主机       | 写数据                                                   |
| HRDATA[31:0] | 从机       | 读数据                                                   |
| HREADY       | 从机       | 传输完成信号，高电平：传输结束；低电平：需要延长传输周期 |
| HRESP[1:0]   | 从机       | 传输状态响应：OKAY,ERROR,RETRY,SPLIT                     |
| HSELx        | 译码器     | 从机选择信号，每个从机都有独立的一根信号线               |

| 名称          | 来源   | 描述                                                         |
| ------------- | ------ | ------------------------------------------------------------ |
| HBUSERQx      | 主机   | 总线使用权请求信号，最多支持16个主机                         |
| HLOCKx        | 主机   | 传输锁定信号，高电平时锁定对总线的访问，在信号为低前不允许其他主机访问总线 |
| HGRANTx       | 仲裁器 | 授权信号，当前主机优先级最高。当HREADY和HGRANTx同时为高时，主机获得总线权利 |
| HMASTER[3:0]  | 仲裁器 | 主机号                                                       |
| HMASTLOCK     | 仲裁器 | 表示当前主机正在执行Locked操作，与HMASTER时序相同            |
| HSPLITx[15:0] | 从机   | 分块请求；告诉仲裁器哪个主机尝试一次split传输，每位对应一个主机 |

+ HTRANS[1:0]：
  + IDLE(00),主设备占用总线但没有传输，如果从设备被选中，需要在每个周期都返回一个OKAY响
  + BUSY（01）主设备占用总线，单在burst传输过程中还没准备好下一次传输，此时主设备需要给出下一拍的地址和控制信号，虽然从设备不会去采样；
  + NONSEQ(10)表明一次单个数据的传输或者一次burst传输的第一个数据地址和控制信号与上一次传输无关
  + SEQ(11)burst传输接下来的数据地址和上一次传输的地址是相关的，这时总线上的控制信号应当与之前的保持一致，地址视情况递增或者回环。
+ HSIZE[2:0]：传输大小，值为8*2^(HSIZE);最小为8bit，最大为1024bit；
+ HRESP[1:0]:
  + 00：okay
  + 01：error
  + 10：retry，传输未完成，请求主设备重新开始一个传输，仲裁器会继续使用通常的优先级
  + 11：split，传输未完成，请求主设备分离一次传输，仲裁器会调整优先级方案以便其他请求总线的主设备可以访问总线。

**传输时序**

**主机时序**

![img](笔记.assets/1227822_201608200005401MxVm.png)

**从机时序**

![img](笔记.assets/1227822_201608201901191dd5S.png)

传输流程分为两个阶段：

+ 地址阶段：一个时钟周期，传输地址和控制指令
+ 数据阶段：一个或多个时钟周期，由HBURST信号决定需要几个有效周期，可以由HREADY发出请求延长一个周期

**无等待的单信号传输**

![img](笔记.assets/20170930182928225)

**有等待状态的单信号传输**

![img](笔记.assets/20170930183051856)

**多个单信号传输的流水线操作**

![img](笔记.assets/20170930183148331)

可以在传输第一个数据时，同时传输下一个数据的地址；

如果在传输时插入了等待周期，对应下一个数据的地址也要多维持一个时钟周期

**burst传输**

![img](笔记.assets/20170930183254118)

根据HBURST的不同传递不同的地址和进行不同类型的burst传输

+ SINGLE：单信号传输
+ INCR :地址递增
+ INCRn：n递增
+ WRAPn:n递增，循环传输

#### APB

+ 应用于慢速外设，如UART、键盘等，不需要仲裁器和译码器
+ 只有一个主机，也就是AHB2APB桥接器（Bridge）
+ 所有的信号必须在**时钟上升沿触发**时传递

##### 接口信号

![主要](笔记.assets/20200722135723312.png)

##### APB状态机

![image-20210719213026476](笔记.assets/image-20210719213026476.png)

| 状态       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| **IDLE**   | 这是APB的默认状态，该状态下，数据信号保持不变，减少功耗      |
| **SETUP**  | 当一笔数据需要传递时，进入**SETUP**。在此状态中，**HADDR[31:0]**地址线会经过译码电路产生指定的**PSELx**信号，使能从机。总线在该状态固定停留一个时钟周期后，进入**ACCESS**状态。 |
| **ACCESS** | 数据有效状态，该状态期间，**PENABLE**被置为1，同时在从**SETUP**到**ACCESS**转换期间，地址，读写标志，选择信号以及写数据信号必须保持不变。如果**PREADY**为低电平，在下个时钟周期继续保持该状态；如果**PREADY**为高电平，则退出该状态，如果之后无传输，则转回**IDLE**，如果有其他传输，则转到**SETUP**。 |

##### 读写时序

**写数据**

![image-20210719215014782](笔记.assets/image-20210719215014782.png)

![image-20210719215024479](笔记.assets/image-20210719215024479.png)

**读数据**

![image-20210719220106341](笔记.assets/image-20210719220106341.png)

![image-20210719220120964](笔记.assets/image-20210719220120964.png)

1. 总线闲置状态时，**PSELx**和PENABLE信号为0；

2. 当接收到一个transfer请求后，在时钟上升沿进入**SETUP**状态，该状态负责传输控制指令的生成，主机根据传输控制信号驱动**PWRITE**,**PADDR**信号，以及**置1**对应**PSELx**信号；如果是写数据，主机同时将写数据驱动到**PWDATA**上；该状态固定维持一个clk周期，在下个clk进入**ENABLE状态**；

3. **ACCESS**状态，该状态为数据有效状态，**PENABLE**信号在该状态期间**置1**；
   + 无等待，则**PREADY**维持高电平，如果是写数据，保持**PADDR**和**PWDATA**保持不变；如果是读数据，从机需要在下个**clk上升沿**之前将读数据传输到**PRDATA**上；在周期末的时钟上升沿进行**PADDR**,**PWDATA**/**PRDATA**的采样，并结束**ACCESS**状态。
   + 有等待，从机会把**PREADY**信号拉低，同时继续保持**ACCESS**状态，等待数据稳定，在数据稳定后，将**PREADY**拉高，在这个时钟周期结束的下个上升沿，进行数据采样。并结束**ACCESSS**状态。

4. 在**ACCESS**结束时，如果有transfer请求则进入**SETUP**状态，否则进入**IDLE**状态。

##### APB Bridge

![image-20210719192939549](笔记.assets/image-20210719192939549.png)

##### AHB和APB的通信



##### AHB突发传输与AXI突发传输的特点

AHB协议需要一次突发传输的所有地址，地址与数据锁定对应关系，后一次突发传输必须在前次传输完成才能进行；

AXI只需要一次突发的首地址，可以连续发送多个突发传输首地址而无需等待前次突发传输完成，并且多个数据可以交错传递，此特征大大提高了总线的利用率；

AHB总线与AXI总线均适用于高性能、高带宽的SoC系统，但AXI具有更好的灵活性，而且能够读写通道并行发送，互不影响；更重要的是，AXI总线支持乱序传输，能够有效地利用总线的带宽，平衡内部系统。因此SoC系统中，均以AXI总线为主总线，通过桥连接AHB总线与APB总线，这样能够增加SoC系统的灵活性，更加合理地把不同特征IP分配到总线上。

***

### AXI总线

#### AXI4

+ AXI总线是一个**芯片内部**的**同步并行**总线

+ 高带宽（总线位宽最高可设为1024位），低延迟

+ 可灵活扩展总线位宽以及拓扑连接

+ 标准化，通用总线

+ 是**AMBA**协议的一部分

  + AMBA：高级微控制器总线架构

    是开放的片内互联的总线标准，能在多主机设计中实现多个控制其和外围设备之间的连接和管理

#### AXI类型

+ AXI4(AXI4-FULL):高性能的存储器映射需求
  + 存储器映射：主机在对从机进行读写操作时，指定一个目标地址，这个地址对应系统存储空间的地址，表示对该空间进行读写操作
+ AXI4-Lite:简化版AXI4；用于低吞吐率存储器映射通信
+ AXI4-Stream：用于高速流数据通信（不需要地址）

#### 优势

+ 标准化
+ AXI4（支持突发256）；AXI4-Lite （单个突发）

#### AXI的工作方式

AXI4和AXI-Lite包含5个独立的通道，通道：将接口按照功能分组

+ 读地址通道(ARC)
+ 写地址通道(AWC)
+ 读数据通道(RDC)
+ 写数据通道(WDC)
+ 写响应通道(RC)

注：只有RC和RDC是从机流向主机，其余通道都是主机流向从机

**读&写地址通道（ARC&AWC）：**

写入本次传输操作所需的地址和控制信息，读写操作都拥有各自的地址通道。

**读数据通道（RC）：**

读数据通道上包括从机发送给主机的读数据，以及从机对于本次读传输操作的回复，具体的读操作状态回复情况会在之后讨论。总线数据位宽可以是 8,16,64,128,256,512 或者是 1024 比特。

**写数据通道（WC）：**

写数据通道用于将主机的写数据传输至从机，位宽和RC的数据位宽相同。WC 有一点 RC 所不具有的特性是拥有 STROBE 信号，用于标识写数据中有效的传输字节。即有些无效的数据，出于减少主机工作量的目的，或者在读写宽度不对称时，被放到写数据通道上和有效数据一起发送。而 STROBE 的信号的作用就是标识出这些无用的数据，告知从机不需要接收无用数据。（Master：我太懒，以至于把所有信号都送过来了）

写数据通道设计有缓存，可超前于从机响应本次传输操作，发起下一次写传输操作。

**写回复通道（RC）：**

用于从机将写操作响应回复给主机。所有写传输操作都需要以写回复通道上接收写响应作为完成信号。再次强调，写回复是针对一次传输操作（transcation）的，而不是针对每一次写数据（data transfer）。

AXI4：由于读写地址通道分离，支持双向同时传输；突发长度最大256；

AXI4-Lite：和AXI4类似，不支持突发传输

AXI4-Stream：和AXI4写通道类似，突发不限制

**数据读写流程**

+ **读操作**

![读操作](笔记.assets/image-20210526210251596.png)

+ **写操作**

![写操作](笔记.assets/image-20210526210311543.png)

#### AXI4信号

**全局信号**

+ ACLK: 所有的传输操作都发生在上升沿
+ ARESETn:全局复位，低电平有效，同步复位

**写地址通道**

![img](笔记.assets/v2-42374204594a9520394b1b56b73024ba_720w.png)

写地址通道的信号可以分为 3 部分：经常用到的基础信号、突发传输的控制信号、内存访问相关以及其他的在基础阶段不是很常用的信号。

基础信号即 AWADDR：传输操作的起始地址，AWVALID 以及 AWREADY：所有通道都使用的握手信号。

突发传输指的是传输一次起始地址后，进行多次地址上连续的读写操作。突发传输有关的操作包括：AWLEN：突发传输的长度，即在一次突发传输中数据传输的个数。AWSIZE：每次突发传输中的数据传输的位宽。AWBURST：突发传输的类型。

其他信号包括和内存原子操作有关的 AWLOCK，AWCACHE，AWPROT 以及用于用户自定义的 AWUSER 信号，都将在以后的文章涉及。（等我自己先用到再说）

**读地址通道**

读地址通道和写地址通道的信号十分类似，就不再从 specification 中截图以及介绍了。

**写数据通道**

![img](笔记.assets/v2-a86e1de580db24ca4372158856043e0e_720w.png)

值得注意的是 AXI4 不再支持 WID 信号，这和 AXI4 的乱序机制有关，AXI4 规定所有数据通道的数据必须顺序发送。

WDATA 与常见的握手信号不再赘述，WDATA 的可使用位宽可以见上文。WSTRB 信号用于标记传输数据中有效的字节，每个 WSTRB 位对应一个字节的位宽，比如数据位宽为 64 位，那么 WSTRB 信号的位宽就是 1 个字节,共 8 位。(感谢评论区纠正)

WLAST 标识一次突发传输中最后一次数据传输，如果没有正确的 WLAST 的信号，就会造成写入地址的混乱，导致从机无法正确接收写数据，从而造成从机不再拉高 READY 信号的现象。

**写回复通道**

![img](笔记.assets/v2-ec803a5b017b365907e7b49ade4120a5_720w.png)

与写数据通道不同，写回复通道支持 BID，即支持乱序的写回复，关于乱序的问题，我们稍后再谈。BRESP 回复上一次的写状态。

**读数据通道**

![img](笔记.assets/v2-02dec0bc29d7f5bf5142afc2bb1edc7d_720w.png)

读数据通道与写数据通道类似，区别有两点：一，支持 RID 信号。二，因为读回复信息在读数据通道上传递，所以集成了 RRESP 信号，用于返回读状态，值得注意的是读回复信号和读数据一样，发送方（source）为从机（slave）。

**握手信号依赖性**

图中的单头箭头表示：其*指向的信号*可以在箭头*起始信号*置起之前或之后置起（**无依赖**）

图中的双头箭头表示：其*指向的信号*必须在箭头*起始信号*置起之后置起（指向信号**依赖**起始信号）

**读传输**

![image-20210606162930744](笔记.assets/image-20210606162930744-1622968172063.png)

**写传输**

![image-20210606163948269](笔记.assets/image-20210606163948269-1622968789827.png)

AXI4中

![image-20210606164215383](笔记.assets/image-20210606164215383-1622968937605.png)

+ 图中注释部分，WVALID应该修改为BVALID

#### 突发传输



#### AXI协议·拓扑

原始支持单对单连接，为主从模式，（只有主机可以发起读写请求）

+ 由主机发起请求
+ 从机对请求进行应答

可以使用**连接器IP**支持一对多，多对一以及N对N连接

+ 连接器相当于一个多路开关，通过轮询或者基于优先级的策略进行开关切换。

#### AXI4-Stream

AXI4-Stream是面向流的传输，不涉及内存地址，**无地址线**。

现总结一下axi_stream:

1. valid 和ready实现握手；

2. strb按照byte指定data中的哪个byte是地址信息或者数据信息；

3. keep按照byte指定data中的哪个byte是字节修饰符，哪个是有效的；

4. last用于声明最后一个，可有可没有

5. 不同于一般数据流的是，这stream可以将空白的字节进行两个包之间的合并，不同的传输stream之间可以通过tid区分，然后交叉传输；如果是相同id，没有last信号，那么他们可以合并；

6. 另外还有user信号用于标记位置或者特殊数据项，提供辅助信息（奇偶性，控制信号），识别一个包的段

看起来很像spi,i2c的那种，不过增加了交错，合并的功能。增加了信号线可以识别空白字符和地址位置的字符。

##### AXI4时序图

***

## FIFO

##### 异步FIFO深度计算

<img src="笔记.assets/image-20210713155934194.png" alt="image-20210713155934194" style="zoom:200%;" />

##### FIFO代码

MCDF中的`slave_fifo.v`代码

```verilog
//------------------------------------------------------------------------------------------------------------------------//
//change log 2017-08-20 fix read pointer and write pointer 
//------------------------------------------------------------------------------------------------------------------------//
module slave_fifo (
input                       clk_i,                  // Clock input 
input                       rstn_i,                 // low level effective 
input [31:0]                chx_data_i,             // Data input                 ---->From outside
input                       a2sx_ack_i,             // Read ack                   ---->From Arbiter
input                       slvx_en_i,              // Write enable To Registers  ---->From Register
input                       chx_valid_i,            // Data is valid From outside ---->From Outside
output reg [31:0]           slvx_data_o,            // Data Output                ---->To Arbiter
output [5:0]                margin_o,               // Data margin                ---->To Registers
output reg                  chx_ready_o,            // Ready to accept data       ---->To outside
output reg                  slvx_val_o,             // read acknowledge Keep to handshake with Arbiter ----> To Arbiter
output reg                  slvx_req_o              // data read enanlb           ---->To Arbiter
);     
//------------------------------Internal variables-------------------//
reg [5:0] wr_pointer_r; // write pointer
reg [5:0] rd_pointer_r; // read pointer
reg [31:0] mem [0:31]; //FIFO 32bits width and 32 deepth
//-----------------------------Variable assignments------------------//
wire full_s, empty_s, rd_en_s ;
wire [5:0] data_cnt_s;
assign full_s = ({~wr_pointer_r[5],wr_pointer_r[4:0]}==rd_pointer_r); //pointer value circulation
assign empty_s = (wr_pointer_r == rd_pointer_r);
assign data_cnt_s = (6'd32 - (wr_pointer_r - rd_pointer_r));// available data number
assign margin_o = data_cnt_s;
assign rd_en_s = a2sx_ack_i;

//-----------Code Start---------------------------------------------//
always @ (*) //ready signal
begin
if (!full_s && slvx_en_i) chx_ready_o = 1'b1;//If FIFO is not full and also enabled it is ready to accept data
else chx_ready_o = 1'b0;
end

always @ (*) //reset signal
begin 
  if (!rstn_i) slvx_req_o = 1'b0;
  else if (!empty_s) slvx_req_o = 1'b1;
  else slvx_req_o = 1'b0;
end 

//write pointer increment
always @ (posedge clk_i or negedge rstn_i)
begin : WRITE_POINTER
  if (!rstn_i) begin
    wr_pointer_r <= 6'b0000;
  end else 
  if (chx_valid_i && chx_ready_o) begin  // write data 
    wr_pointer_r <= wr_pointer_r + 6'b0001;
  end
end

//read pointer increment
always @ (posedge clk_i or negedge rstn_i)
begin : READ_POINTER
  if (!rstn_i) begin
    rd_pointer_r <= 6'b0000;
  end else 
  if (rd_en_s && (!empty_s)) begin
    rd_pointer_r <= rd_pointer_r + 6'b0001;
  end
end

//data output is vaild 
always @ (posedge clk_i or negedge rstn_i)
begin
  if (!rstn_i) slvx_val_o <= 1'b0;
  else if (rd_en_s && (!empty_s))
    slvx_val_o <= 1'b1;
    else slvx_val_o <= 1'b0;
end 

// Memory Read Block 
always  @ (posedge clk_i )
begin : READ_DATA 
  if (rstn_i && rd_en_s && (!empty_s)) begin
    slvx_data_o <= mem[rd_pointer_r[4:0]];
  end
end

// Memory Write Block 
always @ (posedge clk_i)
begin : MEM_WRITE
	if (rstn_i && chx_valid_i && chx_ready_o && slvx_en_i) begin
	  mem[wr_pointer_r[4:0]] <= chx_data_i;
	 end
end

endmodule
```

自己设计的FIFO

同步FIFO

```verilog
module fifo(
);
```



***
## Verilog功能实现

### 检测序列10110

RTL代码：

```verilog
module seq10110(
    input clk,
    input reset,
    input idata,
    input data_en,
    output reg seqen,
    output aseqen);
    
    localparam  IDLE   = 3'b000,
                S1     = 3'b001,
                S10    = 3'b010,
                S101   = 3'b011,
                S1011  = 3'b100;
                //S10110 = 3'b101;

    reg [2:0] state,nstate;
    // state transition
    always @ (posedge clk or reset) begin
        if (reset) begin
            state <= IDLE;   
            nstate <= IDLE;      
        end else if (data_en) begin
            state <= nstate;
        end else begin
            state <= state;
        end
    end

    //nstate generate
    always @( idata or state) begin
        case (state)
            IDLE: nstate = (idata) ? S1 : IDLE;
            S1: nstate = idata ? S1 : S10;
            S10: nstate = idata ? S101 : IDLE;
            S101: nstate = idata ? S1011: S10;
            S1011: nstate = idata ? S1 : S10;
        endcase
    end
    //seqen asynchronization
    assign aseqen = data_en && (state == S1011) && (idata == 0);
    
    //seqen synchronization
    always @(posedge clk  or reset) begin
        if (reset) begin
            seqen <= 0;
        end else begin
            seqen <= (state == S1011) && (idata == 0);
        end
    end
endmodule
```

TB代码：

```systemverilog
`timescale 1ps/1ps
module tb_seq10110;
    
    //module exception
    //input
    reg clk,reset,idata,data_en;
    //output
    wire seqen;
    seq10110 seq1(.clk(clk),
                  .reset(reset),
                  .idata(idata),
                  .data_en(data_en),
                  .seqen(seqen));

    //clk general
    initial clk = 0;
    always #10 clk = ~clk;
    
    //
    initial begin
        reset = 1;
        data_en = 1;
        #100 reset = 0;
        idata = 0;
        #20 idata = 1;
        #20 idata = 0;
        #20 idata = 1;
        #20 idata = 1;
        #20 idata = 0;
        #20 idata = 1;
        #20 idata = 1;
        #20 idata = 0;
        #20 idata = 1;
        #100 $stop();

    end
endmodule
```

仿真命令

Questa：

```shell
vlib work                       --建立工作库
vlog seq10110.v tb_seq10110.sv  --编译源文件
vsim -novopt work.tb_seq10110   --仿真TB模块顶层，不进行优化，如果优化可能会把中间信号优化掉
add wave /*                     --添加所有波形进入波形窗口
run -all                        --运行
quit
```



***

### 斐波那契数列求解

输入n,输出n项斐波那契数列和

```verilog
module fibonacci (
    input clk,
    input reset,
    input [7:0] nth,
    input start,
    output [19:0] result,
    output out_en);

    localparam IDLE = 4'b0001,
               LOAD = 4'b0010,
               CAL  = 4'b0100,
               OUT  = 4'b1000;

    // state shift
    reg [3:0] state,nstate;
    always @(posedge clk ) begin
        if (reset) begin
            state <= IDLE;
            nstate <= IDLE;
        end else begin
            state <= nstate;
        end
    end
    wire cal_end ;
    always @( *) begin
        case (state)
            IDLE: nstate = (start) ? LOAD : IDLE;
            LOAD: nstate = (nth == 1) ? OUT : CAL;
            CAL:  nstate = (cal_end) ? OUT : CAL;
            OUT: nstate = (start) ? LOAD :OUT;
            default : nstate = state;
        endcase
    end
    
    reg [7:0] nth_temp;
    reg [7:0] num;
    reg [19:0] sum_temp;
    reg [19:0] val_n,val_np;
    always @(posedge clk ) begin
        case (nstate)
            IDLE: begin
                nth_temp <= 0;
                num <= 0;
                sum_temp <= 0;
                val_n <= 0;
                val_np <= 0;
            end
            LOAD: begin
                nth_temp <= nth;
                num <= 1;
                sum_temp <= 1;
                val_n <= 1;
                val_np <= 0;
            end
            CAL: begin
                sum_temp <= sum_temp+val_n+val_np;
                num <= num + 1;
                val_n <= val_np + val_n;
                val_np <= val_n;
            end
            OUT: begin
                
            end
        endcase
    end
    //计算结束标志
    assign cal_end = (num == nth_temp);
    //输出驱动
    assign result = (state == OUT) ? sum_temp : 20'b0;
    assign out_en = (state == OUT);
endmodule //fibonacci
```

TB:

```systemverilog
`timescale 1ps/1ps
//  Module: tb_fibonacci
//
module tb_fibonacci;

    reg clk;
    reg reset;
    reg [7:0] nth;
    reg start;
    wire [19:0] result;
    wire out_en;
    fibonacci dut (
                    clk,
                    reset,
                    nth,
                    start,
                    result,
                    out_en);

    //clk general
    initial clk = 0;
    always #10 clk = ~clk;

    initial begin
        bit [19:0] ref_result;
        reset = 1;
        start = 0;
        nth = 10;
        ref_result = cal_fib(nth);
        #100 reset = 0;
        start = 1;
        $display("\n%m\n[INFO] %0t: cal begin", $realtime);
        #20 start = 0;
        $display("[INFO] %0t:nth = %0d",$realtime,nth);
        @(posedge out_en)
        $display("[INFO] %0t:result = %0d",$realtime,result);
        $display("[INFO] %0t:ref_result = %0d",$realtime,ref_result);
        #100
        nth = 1;
        ref_result = cal_fib(nth);
        #20 start = 1;
        $display("[INFO] %0t: cal begin", $realtime);
        #20 start = 0;
        $display("[INFO] %0t:nth = %0d",$realtime,nth);
        #10
        wait(out_en);
        $display("[INFO] %0t:result = %0d",$realtime,result);
        $display("[INFO] %0t:ref_result = %0d",$realtime,ref_result);
        #100
        nth = 5;
        ref_result = cal_fib(nth);
        $display("[INFO] %0t: cal begin", $realtime);
        #20 start = 1;
        $display("[INFO] %0t:nth = %0d",$realtime,nth);
        #20 start = 0;
        #10
        wait(out_en);
        $display("[INFO] %0t:result = %0d",$realtime,result);
        $display("[INFO] %0t:ref_result = %0d",$realtime,ref_result);
        #100
        $stop();
    end

    function bit [19:0] cal_fib(bit[7:0] ntt);
        bit [19:0] temp,a0,a1,at;
        temp = 0;
        a0 = 0;
        a1 = 1;
        at = 0;
        while(ntt) begin
            temp = temp+a1;
            at = a1+a0;
            a0 = a1;
            a1 = at;
            ntt = ntt-1;
        end
        return temp;
    endfunction
endmodule: tb_fibonacci

```

***

### 序列最大值以及质心求解

有512个顺序存放的8位数据，找到最大值及对应位置，另求质心

***

### 找零售货机

A饮料5分，B饮料10分，硬币有5分和10分两种，考虑找零，三段式代码

+ 使用状态机实现
+ 由于按键时间不确定，可能持续多个周期，需要进行边沿检测

```verilog
module vend_machine(
    input clk,
    input rst_n,
    input coin_5,
    input coin_10,
    input drink_5,
    input drink_10,
    output reg [1:0] drinko,
    output reg chang);
    
    
    //边沿检测
    wire acoin_5,acoin_10,adrink_5,adrink_10;
    reg [3:0] tri_1,tri_2;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            tri_1 <= 4'b0000;
            tri_2 <= 4'b0000;
        end else begin
            tri_1 <= {coin_5,coin_10,drink_5,drink_10};
            tri_2 <= tri_1;
        end
    end
    assign acoin_5 = (~tri_2[3]) & tri_1[3];
    assign acoin_10 = (~tri_2[2]) & tri_1[2];
    assign adrink_5 = (~tri_2[1]) & tri_1[1];
    assign adrink_10 = (~tri_2[0]) & tri_1[0];
    //state 
    parameter IDLE = 4'b0001,
              S0   = 4'b0010,
              S1   = 4'b0100,
              S2   = 4'b1000;

    reg [3:0] state,nstate;
    reg [1:0] drink;
    reg [1:0] coin;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            nstate <= IDLE;
        end else begin
            state <= nstate;
        end
    end
    wire en_drink,en_coin;
    assign en_drink = adrink_5 | adrink_10;
    assign en_coin = acoin_5 | acoin_10; 
    assign coin_eng = drink <= coin;
    always @( *) begin
        case (state)
            IDLE: nstate = en_drink ? S0 : IDLE;
            S0: nstate = en_coin ? S1 : S0;
            S1: nstate = coin_eng ? S2 : S1;
            S2: nstate = IDLE;
            default : nstate = IDLE;      
        endcase
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            drink <= 0;
            coin  <= 0;
        end else begin
            case (nstate)
                IDLE:begin
                    drink  <= 0;
                    coin <= 0;
                    drinko <= 0;
                    chang <= 0;
                end
                S0: begin
                    drink <= drink+{adrink_10,adrink_5};
                    coin <= 0;
                end
                S1: begin
                    if (acoin_5)
                        coin <= coin + 1;
                    else if (acoin_10) 
                        coin <= coin + 2;        
                end
                S2: begin
                    drinko <= drink;
                    chang <= (drink < coin);
                end
                default: begin
                    drink <= 0;
                    coin <= 0;
                    chang <= 0;
                    drinko <=0;
                end
            endcase
        end
    end
endmodule //vend_machine
```



***

### 边沿检测电路

单触发器边沿检测电路

```verilog
//one trigger
module edge_detect(
input clk_i, rst_n_i, data_i, //输入端口
output posedge_o,negedge_o		//输出端口
);

//one regester
reg tri_1;

always@(posedge clk_i or negedge rst_n_i)
begin
    if (! rst_n_i)			//置位
    begin
        tri_1 <= 1'b0;
    end
    else
    begin
        tri_1 <= data_i;	//触发器
    end
end

assign negedge_o = tri_1 & (~data_i); 		//下降沿检测
assign posedge_o = (~tri_1) & data_i;     	//上升沿检测
endmodule
```

![单触发器边沿检测](笔记.assets/20190603185418390.png)

边沿脉冲只会保留到最近的一个上升沿或下降沿，保持时间不稳定，可能出现极短时间的脉冲

**改进方法**

多个触发器的边沿检测

```verilog
//two trigger
module edge_detect(
input clk_i, rst_n_i, data_i,
output posedge_o,negedge_o,double_edge_o
);

//two regester
reg tri_1;
reg tri_2;

always@(posedge clk_i or negedge rst_n_i)
begin
    if (! rst_n_i)			//置位
    begin
        tri_1 <= 1'b0;
        tri_2 <= 1'b0;
    end
    else
    begin
        tri_1 <= data_i; 
        tri_2 <= tri_1;  	//二级触发器
    end
end
assign negedge_o = tri_2 & (~tri_1);		//下降沿检测
assign posedge_o = (~tri_2) & tri_1;		//上升沿检测
assign double_edge_o = tri_1 ^ tri_2;		//双边沿检测

endmodule
```

![在这里插入图片描述](笔记.assets/20190604102116880.png)

边沿脉冲会在边沿出现后的第一个clk上升沿出现，并维持一个CLK周期。保持同步

***

+ 

***





***

### 次小值检测

使用Verilog/SV撰写如下功能模块；求输入信号序列din在din_vld为高电平的时间段内的次小值和次小值

模块端口定义

```verilog
module sel_min(
input clk, //时钟信号
input rst_n, //复位信号
input [9:0] din, //10bit无符号数
input din_vld, //输入数据有效信号
output [9:0]  dout, //次小值
output [8:0]  cnt //次小值出现的次数，溢出时重新计数
);
```

使用三个寄存器存储最小值和次小值以及次小值出现次数，并在输入有效数据时根据数据大小更新寄存值

注意点：

+ 最小值和次小值初始化时应为最大值，否则后续数据无法更新寄存器
+ 复位后两个时钟周期不产生有效输出，避免输出初始值

模块代码如下

```verilog
/**
检测输入序列中的次小值和次小值个数
**/
module sec_min (
    input clk, //时钟信号
    input rst_n, //复位信号
    input [9:0] din, //10bit无符号数
    input din_vld, //输入数据有效信号
    output [9:0]  dout, //次小值
    output [8:0]  cnt //次小值出现的次数，溢出时重新计数
);
    //reg
    reg [9:0] secmin,min ;
    reg [8:0] cnt_temp;

    //条件
    wire min_c,secmin_c,cnt_ad;
    assign min_c = (din < min);
    assign secmin_c = (din > min) & (din <secmin);
    assign cnt_ad = din == secmin;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            secmin <= 10'b11_1111_1111;
            min <= 10'b11_1111_1111;
            cnt_temp <= 0;
        end else if(din_vld) begin
            if (min_c) begin
                min <= din;
                secmin <= min;
                cnt_temp <= 1;
            end else if(secmin_c) begin
                secmin <= din;
                cnt_temp <= 1;
            end else begin
                cnt_temp <= cnt_ad ? cnt_temp + 1 : cnt_temp;
            end
        end else begin
            min <= min;
            secmin <= secmin;
            cnt_temp <= cnt_temp;
        end       
    end
    //避免初始值输出
    reg [1:0] init_cnt;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            init_cnt <= 0;
        end else begin
            init_cnt <= (init_cnt == 2) ? init_cnt :init_cnt + 1;
        end
    end
    assign dout = (init_cnt >= 2)? secmin : 10'bz;
    assign cnt = cnt_temp;
endmodule //sel_min
```

测试代码

+ 使用systemverilog所有的类和随机化特性，更好的产生输入序列
+ 注意，类需要在使用前定义，同时类的指针例化需要在initial块外，和模块端口为同级别

```systemverilog
//  Module: tb_sec_min
//
`timescale 1ps/1ps

class My_din;
    rand logic [9:0] data[$];
    bit [7:0] cnt;
    logic [9:0] min,secmin;
    string name;
    constraint c {
        data.size() inside {[50:60]};
        foreach (data[i]) 
            data[i] inside {[0:50]};
        
        
    };
    
    function new(string name = "dinseq");
        this.name = name;
    endfunction

    function void display(string prefix);
        foreach(data[i])
        $display("[%s]%0t %s data[%0d] = %0d", prefix, $realtime, name, i, data[i]);
    endfunction
endclass

module tb_sec_min;
    
    My_din pac1;//类指针的声明要在initial外
    logic clk; //时钟信号
    logic rst_n; //复位信号
    logic [9:0] din; //10bit无符号数
    logic din_vld; //输入数据有效信号
    logic [9:0]  dout; //次小值
    logic [8:0]  cnt;//次小值出现的次数，溢出时重新计数


    sec_min dut(
        .clk(clk), //时钟信号
        .rst_n(rst_n), //复位信号
        .din(din), //10bit无符号数
        .din_vld(din_vld), //输入数据有效信号
        .dout(dout), //次小值
        .cnt(cnt) //次小值出现的次数，溢出时重新计数
    );

    initial begin
        clk  = 0;
        forever #10 clk = ~clk;
    end

    initial begin
        rst_n = 0;
        din_vld = 0;
        
        pac1 = new("pac1");
        assert (pac1.randomize());
        pac1.display("data gerenal");
        #100
        rst_n = 1;
        foreach (pac1.data[i]) begin
            din <= pac1.data[i];
            din_vld <= 1;
            @(posedge clk);
        end
        din_vld <= 0;
        @(posedge clk);
        #100

        assert (pac1.randomize());
        pac1.display("seq2");
        foreach (pac1.data[i]) begin
            din <= pac1.data[i];
            din_vld <= 1;
            @(posedge clk);
        end
        din_vld <= 0;
        @(posedge clk);
        #100
        $stop();
    end


endmodule: tb_sec_min
```



***

### CRC计算

![image-20210604104845427](file://E:\%E6%A1%8C%E9%9D%A2\%E7%AC%94%E8%AE%B0.assets\image-20210604104845427.png?lastModify=1625649542)

多项式表达为：$G(D)=D8+D2+D+1$

+ CRC循环校验码

+ CRC-8，输出的CRC值为8位

模块代码：

```verilog
module crc8 (
    input  clk,
    input  rst_n,
    input  data,
    input  data_valid,
    input  crc_start, //CRC开始信号，持续一个clk
    output wire crc_out,  //crc 串行输出
    output reg crc_valid //CRC valid
);

    reg [7:0] shift_reg ;
    reg [7:0] crc8_out;

    parameter IDLE = 3'b001,
              CAL  = 3'b010,
              CRCO = 3'b100;

    reg [2:0] state,nstate;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state  <= IDLE;
            nstate <= IDLE;
        end else begin
            state <= nstate;
        end
    end  
    wire cal_end;
    wire out_end;

    always @( *) begin
        case (state)
            IDLE    : nstate = (crc_start) ? CAL : IDLE;
            CAL     : nstate = (cal_end) ? CRCO : CAL;
            CRCO    : nstate = (out_end) ? IDLE : CRCO;
            default : nstate = IDLE;
        endcase
    end
    reg [5:0] cnt_crc;
    reg [2:0] cnt_out;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            cnt_crc <= 0;
        end else if (crc_start) begin
            cnt_crc <= 0;
        end else if (data_valid) begin
            cnt_crc <= cnt_crc + 1;
        end else
            cnt_crc <= cnt_crc;
    end
    assign cal_end = (cnt_crc == 6'd32);

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            cnt_out <= 0;
        end else if(nstate == CAL) begin
            cnt_out <= 0;
        end else if (state == CRCO) begin
            cnt_out <= cnt_out + 1;
        end
    end
    assign out_end = (cnt_out == 3'd7);

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            crc_valid <= 0;
        end else begin
            crc_valid <= (nstate == CRCO) ? 1 : 0;
        end
    end
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            shift_reg <= 8'h00;
        end else if (crc_start) begin
            shift_reg <= 8'h00;
        end else if (data_valid) begin
            shift_reg[0] <= data ^ shift_reg[7];
            shift_reg[1] <= shift_reg[0] ^ data ^ shift_reg[7];
            shift_reg[2] <= shift_reg[1] ^ data ^ shift_reg[7];
            shift_reg[3] <= shift_reg[2];
            shift_reg[4] <= shift_reg[3];
            shift_reg[5] <= shift_reg[4];
            shift_reg[6] <= shift_reg[5];
            shift_reg[7] <= shift_reg[6];
            crc8_out     <= shift_reg;
        end
    end
    assign crc_out = crc_valid ? crc8_out[7-cnt_out] : 0;
endmodule //crc8
```

测试代码

```systemverilog
`timescale 1ps/1ps
//  Module: tb_crc8
//
class data_32;
    rand bit data[$];
    string name;
    constraint c {
        /*  solve order constraints  */
        data.size() == 32;
        /*  rand variable constraints  */   
    }
    
    function new(string name = "dinseq");
        this.name = name;
    endfunction

    function void display(string prefix);
        foreach(data[i])
        $display("[%s]%0t %s data[%0d] = %0d", prefix, $realtime, name, i, data[i]);
    endfunction
endclass
module tb_crc8;
    //例化
    logic clk;
    logic rst_n;
    logic data;
    logic data_valid;
    logic crc_start; //CRC开始信号，持续一个clk
    logic crc_out;  //crc 串行输出
    logic crc_valid; //CRC valid

    crc8 dut (
        clk,
        rst_n,
        data,
        data_valid,
        crc_start, //CRC开始信号，持续一个clk
        crc_out,  //crc 串行输出
        crc_valid //CRC valid
    );

    //
    data_32 data1;
    initial begin
        clk = 0;
        forever #10 clk = ~clk;
    end
    
    initial begin
        data1 = new();
        assert (data1.randomize());
        data1.display("data gerenal");
        rst_n <= 0;
        data_valid <= 0;
        crc_start <= 0;
        #100
        rst_n <=1;
        @(posedge clk);
        crc_start <= 1;
        @(posedge clk);
        crc_start <= 0;
        @(posedge clk);
        foreach (data1.data[i]) begin
            data <= data1.data[i];
            data_valid <= 1;
            @(posedge clk);
        end
        data_valid <= 0;
        @(posedge clk);
        @(negedge crc_valid);
        repeat(5) @(posedge clk);
        $stop();
    end
endmodule: tb_crc8
```



***

## SV的仿真调度机制

![image-20210707155137746](笔记.assets/image-20210707155137746.png)

SV仿真的执行分为一个个时间片执行，在每个时间片中语句的执行顺序如上图所示。

preponed：数据为上一个时间片中的最终稳定值，断言所判断的数据在该区域采样。

仿真模块中的设计代码执行

Active：执行process语句（always，assign，initial），阻塞赋值，连续赋值及非阻塞赋值右侧的求值表达式；原语计算以及调用系统函数。

Inactive：执行带有“#0”延时的线程；因此“#0”延时会延缓线程的操作时间。

NBA：前两个区域线程执行结束后，进入该区域，并使非阻塞赋值生效。

验证平台区域

Observed：使用preponed区域中采样的值来评估并发断言中的属性是否成立。属性评估在任何一个时间片中只发生一次。

Reactive：断言语句判断（数据在preponed中采集）。以及testbench区域中的线程也在该区域执行。该区域可进一步拆分出Re_inactive和Re_NBA。

+ Reactive：执行program中的连续赋值，阻塞赋值以及非阻塞赋值的右式计算
+ Re_inactive：同inactive区域类似，执行program块中的#0零延迟阻塞赋值。
+ Re_NBA区域：同NBA区域类似，执行program块中的非阻塞赋值左值更新。

Postpone：同下一时钟片中的preponed区域一样的值，代表本时钟片中的最终稳定值。

在仿真时，使用program快将设计和验证的调度区域分开，将设计部分放在module中，将测试采样部分放置在program中。

+ program中不使用always，module，interface定义，不出现其他program的例化
+ 可在program中定义变量以及发起多个initial块
+ 内部变量赋值使用阻塞赋值（软件方式）
+ 驱动外部的硬件信号时使用非阻塞赋值（硬件方式）
+ program中的initial块在reactive中执行，module中的initial块在active中执行

***

## MCDF



***

## 语法小点

+ ``timescale a/b`

  a为延时单位，b为时间精度，即#100这种延时表达式的单位为a,实际仿真能达到的时间精度为b

+ 

***

# 公司

+ 海康威视2022届秋招正式开始啦，早投递，早面试，早offer，内推码D27EAW，校招专属答疑群583868905，758653634填写内推码可享受优先简历筛选与专属答疑，进程查询服务。

![img](笔记.assets/}@XSOC[R58NFVIZ_FR]FMB3.jpg)

全志

投完记得简历发2351090323@qq.com 一份

![image-20210706152158824](笔记.assets/image-20210706152158824.png)

![img](笔记.assets/CM8S9T5XYWHMYKRG2QG9JSW.jpg)

***

# 面经

> https://blog.csdn.net/gemengxia/article/details/108344781
>
> 
