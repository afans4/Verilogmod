## IC笔记
#### 序列检测机
检测序列10110
RTL代码：

```verilog
module seq10110(
    input clk,
    input reset,
    input idata,
    input data_en,
    output reg seqen,
    output aseqen);
    
    localparam  IDLE   = 3'b000,
                S1     = 3'b001,
                S10    = 3'b010,
                S101   = 3'b011,
                S1011  = 3'b100;
                //S10110 = 3'b101;

    reg [2:0] state,nstate;
    // state transition
    always @ (posedge clk or reset) begin
        if (reset) begin
            state <= IDLE;   
            nstate <= IDLE;      
        end else if (data_en) begin
            state <= nstate;
        end else begin
            state <= state;
        end
    end

    //nstate generate
    always @( idata or state) begin
        case (state)
            IDLE: nstate = (idata) ? S1 : IDLE;
            S1: nstate = idata ? S1 : S10;
            S10: nstate = idata ? S101 : IDLE;
            S101: nstate = idata ? S1011: S10;
            S1011: nstate = idata ? S1 : S10;
        endcase
    end
    //seqen asynchronization
    assign aseqen = data_en && (state == S1011) && (idata == 0);
    
    //seqen synchronization
    always @(posedge clk  or reset) begin
        if (reset) begin
            seqen <= 0;
        end else begin
            seqen <= (state == S1011) && (idata == 0);
        end
    end
endmodule
```

TB代码：

```systemverilog
`timescale 1ps/1ps
module tb_seq10110;
    
    //module exception
    //input
    reg clk,reset,idata,data_en;
    //output
    wire seqen;
    seq10110 seq1(.clk(clk),
                  .reset(reset),
                  .idata(idata),
                  .data_en(data_en),
                  .seqen(seqen));

    //clk general
    initial clk = 0;
    always #10 clk = ~clk;
    
    //
    initial begin
        reset = 1;
        data_en = 1;
        #100 reset = 0;
        idata = 0;
        #20 idata = 1;
        #20 idata = 0;
        #20 idata = 1;
        #20 idata = 1;
        #20 idata = 0;
        #20 idata = 1;
        #20 idata = 1;
        #20 idata = 0;
        #20 idata = 1;
        #100 $stop();

    end
endmodule
```

仿真命令

Questa：

```shell
vlib work                       --建立工作库
vlog seq10110.v tb_seq10110.sv  --编译源文件
vsim -novopt work.tb_seq10110   --仿真TB模块顶层，不进行优化，如果优化可能会把中间信号优化掉
add wave /*                     --添加所有波形进入波形窗口
run -all                        --运行
quit
```



***

#### 斐波那契数列求解

输入n,输出n项斐波那契数列和

```verilog
module fibonacci (
    input clk,
    input reset,
    input [7:0] nth,
    input start,
    output [19:0] result,
    output out_en);

    localparam IDLE = 4'b0001,
               LOAD = 4'b0010,
               CAL  = 4'b0100,
               OUT  = 4'b1000;

    // state shift
    reg [3:0] state,nstate;
    always @(posedge clk ) begin
        if (reset) begin
            state <= IDLE;
            nstate <= IDLE;
        end else begin
            state <= nstate;
        end
    end
    wire cal_end ;
    always @( *) begin
        case (state)
            IDLE: nstate = (start) ? LOAD : IDLE;
            LOAD: nstate = (nth == 1) ? OUT : CAL;
            CAL:  nstate = (cal_end) ? OUT : CAL;
            OUT: nstate = (start) ? LOAD :OUT;
            default : nstate = state;
        endcase
    end
    
    reg [7:0] nth_temp;
    reg [7:0] num;
    reg [19:0] sum_temp;
    reg [19:0] val_n,val_np;
    always @(posedge clk ) begin
        case (nstate)
            IDLE: begin
                nth_temp <= 0;
                num <= 0;
                sum_temp <= 0;
                val_n <= 0;
                val_np <= 0;
            end
            LOAD: begin
                nth_temp <= nth;
                num <= 1;
                sum_temp <= 1;
                val_n <= 1;
                val_np <= 0;
            end
            CAL: begin
                sum_temp <= sum_temp+val_n+val_np;
                num <= num + 1;
                val_n <= val_np + val_n;
                val_np <= val_n;
            end
            OUT: begin
                
            end
        endcase
    end
    //计算结束标志
    assign cal_end = (num == nth_temp);
    //输出驱动
    assign result = (state == OUT) ? sum_temp : 20'b0;
    assign out_en = (state == OUT);
endmodule //fibonacci
```

TB:

```systemverilog
`timescale 1ps/1ps
//  Module: tb_fibonacci
//
module tb_fibonacci;

    reg clk;
    reg reset;
    reg [7:0] nth;
    reg start;
    wire [19:0] result;
    wire out_en;
    fibonacci dut (
                    clk,
                    reset,
                    nth,
                    start,
                    result,
                    out_en);

    //clk general
    initial clk = 0;
    always #10 clk = ~clk;

    initial begin
        bit [19:0] ref_result;
        reset = 1;
        start = 0;
        nth = 10;
        ref_result = cal_fib(nth);
        #100 reset = 0;
        start = 1;
        $display("\n%m\n[INFO] %0t: cal begin", $realtime);
        #20 start = 0;
        $display("[INFO] %0t:nth = %0d",$realtime,nth);
        @(posedge out_en)
        $display("[INFO] %0t:result = %0d",$realtime,result);
        $display("[INFO] %0t:ref_result = %0d",$realtime,ref_result);
        #100
        nth = 1;
        ref_result = cal_fib(nth);
        #20 start = 1;
        $display("[INFO] %0t: cal begin", $realtime);
        #20 start = 0;
        $display("[INFO] %0t:nth = %0d",$realtime,nth);
        #10
        wait(out_en);
        $display("[INFO] %0t:result = %0d",$realtime,result);
        $display("[INFO] %0t:ref_result = %0d",$realtime,ref_result);
        #100
        nth = 5;
        ref_result = cal_fib(nth);
        $display("[INFO] %0t: cal begin", $realtime);
        #20 start = 1;
        $display("[INFO] %0t:nth = %0d",$realtime,nth);
        #20 start = 0;
        #10
        wait(out_en);
        $display("[INFO] %0t:result = %0d",$realtime,result);
        $display("[INFO] %0t:ref_result = %0d",$realtime,ref_result);
        #100
        $stop();
    end

    function bit [19:0] cal_fib(bit[7:0] ntt);
        bit [19:0] temp,a0,a1,at;
        temp = 0;
        a0 = 0;
        a1 = 1;
        at = 0;
        while(ntt) begin
            temp = temp+a1;
            at = a1+a0;
            a0 = a1;
            a1 = at;
            ntt = ntt-1;
        end
        return temp;
    endfunction
endmodule: tb_fibonacci

```

***

#### 芯片功耗

$$
总功耗=开关功耗+短路功耗+静态功耗
$$

动态功耗包括开关功耗和短路功耗
$$
开关功耗=C\bullet V^2 \bullet F
$$
其中$C$为负载电容，$V$是电压，$F$是频率
$$
短路功耗 = V \bullet I(短路)
$$
其中$I(短路)$为在开关切换过程中N极和P极同时有效时发生的短路电流。
$$
静态功耗= V \cdot I(漏电)
$$
静态功耗（漏电功耗）是晶体管在电路稳定时出现的漏电造成的功耗

***

#### FIFO

MCDF中的`slave_fifo.v`代码

```verilog
//------------------------------------------------------------------------------------------------------------------------//
//change log 2017-08-20 fix read pointer and write pointer 
//------------------------------------------------------------------------------------------------------------------------//
module slave_fifo (
input                       clk_i,                  // Clock input 
input                       rstn_i,                 // low level effective 
input [31:0]                chx_data_i,             // Data input                 ---->From outside
input                       a2sx_ack_i,             // Read ack                   ---->From Arbiter
input                       slvx_en_i,              // Write enable To Registers  ---->From Register
input                       chx_valid_i,            // Data is valid From outside ---->From Outside
output reg [31:0]           slvx_data_o,            // Data Output                ---->To Arbiter
output [5:0]                margin_o,               // Data margin                ---->To Registers
output reg                  chx_ready_o,            // Ready to accept data       ---->To outside
output reg                  slvx_val_o,             // read acknowledge Keep to handshake with Arbiter ----> To Arbiter
output reg                  slvx_req_o              // data read enanlb           ---->To Arbiter
);     
//------------------------------Internal variables-------------------//
reg [5:0] wr_pointer_r; // write pointer
reg [5:0] rd_pointer_r; // read pointer
reg [31:0] mem [0:31]; //FIFO 32bits width and 32 deepth
//-----------------------------Variable assignments------------------//
wire full_s, empty_s, rd_en_s ;
wire [5:0] data_cnt_s;
assign full_s = ({~wr_pointer_r[5],wr_pointer_r[4:0]}==rd_pointer_r); //pointer value circulation
assign empty_s = (wr_pointer_r == rd_pointer_r);
assign data_cnt_s = (6'd32 - (wr_pointer_r - rd_pointer_r));// available data number
assign margin_o = data_cnt_s;
assign rd_en_s = a2sx_ack_i;

//-----------Code Start---------------------------------------------//
always @ (*) //ready signal
begin
if (!full_s && slvx_en_i) chx_ready_o = 1'b1;//If FIFO is not full and also enabled it is ready to accept data
else chx_ready_o = 1'b0;
end

always @ (*) //reset signal
begin 
  if (!rstn_i) slvx_req_o = 1'b0;
  else if (!empty_s) slvx_req_o = 1'b1;
  else slvx_req_o = 1'b0;
end 

//write pointer increment
always @ (posedge clk_i or negedge rstn_i)
begin : WRITE_POINTER
  if (!rstn_i) begin
    wr_pointer_r <= 6'b0000;
  end else 
  if (chx_valid_i && chx_ready_o) begin  // write data 
    wr_pointer_r <= wr_pointer_r + 6'b0001;
  end
end

//read pointer increment
always @ (posedge clk_i or negedge rstn_i)
begin : READ_POINTER
  if (!rstn_i) begin
    rd_pointer_r <= 6'b0000;
  end else 
  if (rd_en_s && (!empty_s)) begin
    rd_pointer_r <= rd_pointer_r + 6'b0001;
  end
end

//data output is vaild 
always @ (posedge clk_i or negedge rstn_i)
begin
  if (!rstn_i) slvx_val_o <= 1'b0;
  else if (rd_en_s && (!empty_s))
    slvx_val_o <= 1'b1;
    else slvx_val_o <= 1'b0;
end 

// Memory Read Block 
always  @ (posedge clk_i )
begin : READ_DATA 
  if (rstn_i && rd_en_s && (!empty_s)) begin
    slvx_data_o <= mem[rd_pointer_r[4:0]];
  end
end

// Memory Write Block 
always @ (posedge clk_i)
begin : MEM_WRITE
	if (rstn_i && chx_valid_i && chx_ready_o && slvx_en_i) begin
	  mem[wr_pointer_r[4:0]] <= chx_data_i;
	 end
end

endmodule
```

自己设计的FIFO

同步FIFO

```verilog
module fifo(
);
```



***

#### 找零售货机

A饮料5分，B饮料10分，硬币有5分和10分两种，考虑找零，三段式代码

+ 使用状态机实现
+ 由于按键时间不确定，可能持续多个周期，需要进行边沿检测

```verilog
module vend_machine(
    input clk,
    input rst_n,
    input coin_5,
    input coin_10,
    input drink_5,
    input drink_10,
    output reg [1:0] drinko,
    output reg chang);
    
    
    //边沿检测
    wire acoin_5,acoin_10,adrink_5,adrink_10;
    reg [3:0] tri_1,tri_2;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            tri_1 <= 4'b0000;
            tri_2 <= 4'b0000;
        end else begin
            tri_1 <= {coin_5,coin_10,drink_5,drink_10};
            tri_2 <= tri_1;
        end
    end
    assign acoin_5 = (~tri_2[3]) & tri_1[3];
    assign acoin_10 = (~tri_2[2]) & tri_1[2];
    assign adrink_5 = (~tri_2[1]) & tri_1[1];
    assign adrink_10 = (~tri_2[0]) & tri_1[0];
    //state 
    parameter IDLE = 4'b0001,
              S0   = 4'b0010,
              S1   = 4'b0100,
              S2   = 4'b1000;

    reg [3:0] state,nstate;
    reg [1:0] drink;
    reg [1:0] coin;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            nstate <= IDLE;
        end else begin
            state <= nstate;
        end
    end
    wire en_drink,en_coin;
    assign en_drink = adrink_5 | adrink_10;
    assign en_coin = acoin_5 | acoin_10; 
    assign coin_eng = drink <= coin;
    always @( *) begin
        case (state)
            IDLE: nstate = en_drink ? S0 : IDLE;
            S0: nstate = en_coin ? S1 : S0;
            S1: nstate = coin_eng ? S2 : S1;
            S2: nstate = IDLE;
            default : nstate = IDLE;      
        endcase
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            drink <= 0;
            coin  <= 0;
        end else begin
            case (nstate)
                IDLE:begin
                    drink  <= 0;
                    coin <= 0;
                    drinko <= 0;
                    chang <= 0;
                end
                S0: begin
                    drink <= drink+{adrink_10,adrink_5};
                    coin <= 0;
                end
                S1: begin
                    if (acoin_5)
                        coin <= coin + 1;
                    else if (acoin_10) 
                        coin <= coin + 2;        
                end
                S2: begin
                    drinko <= drink;
                    chang <= (drink < coin);
                end
                default: begin
                    drink <= 0;
                    coin <= 0;
                    chang <= 0;
                    drinko <=0;
                end
            endcase
        end
    end
endmodule //vend_machine
```



***

#### 边沿检测电路

单触发器边沿检测电路

```verilog
//one trigger
module edge_detect(
input clk_i, rst_n_i, data_i, //输入端口
output posedge_o,negedge_o		//输出端口
);

//one regester
reg tri_1;

always@(posedge clk_i or negedge rst_n_i)
begin
    if (! rst_n_i)			//置位
    begin
        tri_1 <= 1'b0;
    end
    else
    begin
        tri_1 <= data_i;	//触发器
    end
end

assign negedge_o = tri_1 & (~data_i); 		//下降沿检测
assign posedge_o = (~tri_1) & data_i;     	//上升沿检测
endmodule
```

![单触发器边沿检测](笔记.assets/20190603185418390.png)

边沿脉冲只会保留到最近的一个上升沿或下降沿，保持时间不稳定，可能出现极短时间的脉冲

**改进方法**

多个触发器的边沿检测

```verilog
//two trigger
module edge_detect(
input clk_i, rst_n_i, data_i,
output posedge_o,negedge_o,double_edge_o
);

//two regester
reg tri_1;
reg tri_2;

always@(posedge clk_i or negedge rst_n_i)
begin
    if (! rst_n_i)			//置位
    begin
        tri_1 <= 1'b0;
        tri_2 <= 1'b0;
    end
    else
    begin
        tri_1 <= data_i; 
        tri_2 <= tri_1;  	//二级触发器
    end
end
assign negedge_o = tri_2 & (~tri_1);		//下降沿检测
assign posedge_o = (~tri_2) & tri_1;		//上升沿检测
assign double_edge_o = tri_1 ^ tri_2;		//双边沿检测

endmodule
```

![在这里插入图片描述](笔记.assets/20190604102116880.png)

边沿脉冲会在边沿出现后的第一个clk上升沿出现，并维持一个CLK周期。保持同步

***

#### 跨时钟域处理（CDC）

> https://blog.csdn.net/vivid117/article/details/117567445
>
> 

##### 亚稳态

**产生原因**：不同时钟域导致的触发器的数据输入没有满足建立时间和保持时间，导致采集到一个无法确认的数据输入

+ 亚稳态是指信号跳变时，由于**不满足建立保持时间**，寄存器的输出端会输出中间电平，或者产生震荡等。亚稳态**不是一个持续的状态**，是一个短暂的状态。
+ 对于异步信号，一级寄存器永远会有亚稳态的可能。
+ 如果第一级寄存器出现亚稳态，亚稳态的时间如果在1个clock cycle之内恢复了，那么第二级寄存器会采样到稳定状态。如果亚稳态时间过于长超过1个clock cycle，那么第二级仍然有可能输出亚稳态。
+ 亚稳态不是纠错，如果产生亚稳态，那么采样值可能是不正确的，两级寄存器或者多级寄存器的级联是防止亚稳态状态在时序电路中传播扩散。

**亚稳态处理**

1. 降低系统时钟
2. 用反应更快的FF
3. 引入**同步机制**，防止亚稳态传播
4. 改善时钟质量，用边沿变化快速的时钟信号

**同步器**

常用2级同步器(打两拍)降低亚稳态发生的概率。

原理：亚稳态是一个短暂状态，二级同步器可以增加一个CLK的时间等待亚稳态稳定

+ 同步器能降低亚稳态发生的**概率**，但不能保证采集到**正确的信号**

即： 同步器或增加寄存器可以避免亚稳态的**传播**，但不能纠正**逻辑正确性**

##### 单比特跨时钟域处理

**常用处理方法**

慢时间到快时间域

1. 两级寄存器同步(打两拍)，(频率相差2倍以上)
2. 边沿检测同步器(频率相差2倍以上)，可避免快时钟多次采集到有效信号。
3. 握手处理(单比特少用)，一般用于时钟频率相差不大的情况(频率相差2倍以下)，为了避免快时钟**采样丢失**，进行握手的同步处理。

**边沿检测**

1. 上升沿检测

   快时钟先将输入信号进行两级同步处理，再进行一个时钟的延迟，**延迟后的信号取反**与**同步信号做与逻辑**，得到信号的上升沿。

2. 下降沿检测

   快时钟先将输入信号进行两级同步处理，再进行一个时钟的延迟，延迟后的信号与**取反后同步信号做与**逻辑，得到脉冲信号的下降沿。

3. 双边沿检测

   快时钟先将输入信号进行两级同步处理，再进行一个时钟的延迟，延迟后的信号与同步信号做**异或**逻辑，就可得到信号的双沿脉冲。

快时间到慢时间域同步

1. 电平拓展

   如果已知慢时钟域的时钟频率，可以考虑将快时钟域的信号进行电平扩展，使得足以被慢时钟域采样。

2. 脉冲同步器

   快时钟域中需要同步的是脉冲信号，将快时钟域脉冲同步为慢时钟域脉冲

   原理是**翻转电路+边沿检测电路**

   需要脉冲是**单脉冲信号**；多个脉冲之间需要**大于两个**慢时间同步周期

3. 握手处理

注意：

多个关联单比特信号不可以通过打拍的方式同步到目的时钟域，应该在原时钟域进行逻辑运算再锁存后打拍处理

***

#### 竞争与冒险

+ 组合逻辑电路
+ 由于信号电平翻转时会有一段时间处于亚稳态

![在这里插入图片描述](笔记.assets/20200509153439630.png)

+ 竞争：在组合电路中，信号经由不同的途径达到某一会合点的时间有先有后，这种现象称为竞争。

  冒险：由于竞争而引起电路输出发生瞬间错误现象称为冒险。表现为输出端出现了原设计中没有的窄脉冲，常称其为毛刺。

  竞争与冒险的关系：有竞争不一定会产生冒险，但有冒险就一定有竞争。

  在组合逻辑中，由于门的输入信号通路中经过了不同的延时，导致到达该门的时间不一致叫竞争。
  产生毛刺叫冒险。如果布尔式中有相反的信号则可能产生竞争和冒险现象。

判定依据：

- 如果输出端门电路的两个输入信号A和A’是输入变量A经过两个不同的传输途径而来，则当输入变量A的状态发生突变时输出端有可能产生尖峰脉冲，故**只要输出端的逻辑函数在一定条件下能简化成Y＝A＋ A’或 Y＝A · A’,则可判定存在竞争－冒险现象**

两种情况：

+ $Y=A+A'$，产生一个低电平
+ $Y = A\cdot A'$，产生一个尖峰脉冲，高电平脉冲

消除方法：

+ 接入滤波电容：在门电路的输出端并接一个很小的滤波电容，简单，但是会使输出波形变差

+ 引入选通脉冲：门电路的输入或者输出加一个选通控制器，使电路在输入稳定后再输出结果即可。

+ 修改逻辑设计：增加**冗余项**

  例子：

  $Y=AB+A'C$,当$B = C = 1$时：$Y = A + A ′$ 
  说明此电路存在竞争冒险现象。
  增加冗余项，$Y = A B + A ′ C + B C$ 

***

#### 电路静态时序分析

> 参考材料
>
> https://zhuanlan.zhihu.com/p/87462839
>
> https://blog.csdn.net/verylogic/article/details/14261989?reload



时序分析要求：

+ 在第二个FF的第二个上升沿到来前的建立时间前数据到达第二个FF的入口
+ 数据要保持到第二个上升沿后再加上保持时间后

经典分析模型如下：

![image-20210629212327146](笔记.assets/image-20210629212327146.png)

![image-20210629213711623](笔记.assets/image-20210629213711623.png)

以CLK的第一个上升沿为0时刻

FF1 CLK在T_clk1时出现第一个上升沿，此时，FF1打开，数据进入FF1

经过T_cko后，数据到达FF1的输出Q，

再经过T_logic后通过组合逻辑电路，再经过T_net线路延时到达FF2的输入。

总时间为$T_{cl1}+T_{clo}+T_{logic}+T_{net}$，

*时序要求数据在FF2 CLK的第二个上升沿到来前到达FF2输入，同时要满足建立时间和保持时间*

FF2 CLK的第二个上升沿的时刻为$T_{clk2}+T_{clkp}$,$T_{clkp}$为时钟周期

数据建立时间和保留时间要求为$T_{su}$和$T_{hold}$

因此建立时间要求如下
$$
T_{clk2}+T_{clkp}-T{su}>T_{clk1}+T_{clo}+T_{logic}+T_{net}
$$
可得到时钟周期的约束条件
$$
T_{clkp}>T_{clk1}-T_{clk2}+T_{clo}+T_{logic}+T_{net}+T{su}
$$
保持时间要求如下
$$
T_{clk2}+T_{clkp}+T_{hold}<T_{clk1}+T_{clo}+T_{logic}+T_{net}+T_{clkp}
$$
化简为
$$
T_{clk2}+T_{hold}<T_{clk1}+T_{clo}+T_{logic}+T_{net}
$$
例题如下

![](笔记.assets/image-20210629153338758.png)

